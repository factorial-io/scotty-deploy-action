name: 'Scotty Deploy'
description: 'Deploy docker-compose applications to Scotty (micro-PaaS)'
author: 'Factorial GmbH'
branding:
  icon: 'box'
  color: 'blue'

inputs:
  # Required inputs
  scotty-server:
    description: 'URL of the Scotty server'
    required: true
  scotty-token:
    description: 'Access token for Scotty authentication'
    required: true
  app-name:
    description: 'Unique name for the application'
    required: true
  service:
    description: 'Service(s) to expose publicly in format SERVICE:PORT (multi-line supported, one per line)'
    required: false

  # Action control
  action:
    description: 'Action to perform: create or destroy'
    required: false
    default: 'create'

  # Deployment configuration
  folder:
    description: 'Path to folder containing compose.yml'
    required: false
    default: '.'
  app-blueprint:
    description: 'Use a pre-configured blueprint instead of services'
    required: false
    default: ''
  ttl:
    description: 'Time to live (e.g., 2h, 30m, 1d, 7d, forever)'
    required: false
    default: '24h'

  # Access control
  basic-auth:
    description: 'HTTP basic authentication as USERNAME:PASSWORD'
    required: false
    default: ''
  allow-robots:
    description: 'Allow search engine indexing (default adds X-Robots-Tag: noindex)'
    required: false
    default: 'false'
  destroy-on-ttl:
    description: 'Destroy app after TTL instead of just stopping it'
    required: false
    default: 'false'

  # Advanced configuration
  custom-domain:
    description: 'Custom domain mapping(s) in format DOMAIN:SERVICE (multi-line supported, one per line)'
    required: false
    default: ''
  env:
    description: 'Environment variable(s) in format KEY=VALUE (multi-line supported, one per line)'
    required: false
    default: ''
  env-file:
    description: 'Path to environment file'
    required: false
    default: ''
  registry:
    description: 'Private registry name (must be configured on server)'
    required: false
    default: ''
  middleware:
    description: 'Traefik middleware name(s) (multi-line supported, one per line)'
    required: false
    default: ''

  # Tool configuration
  scottyctl-version:
    description: 'Docker image tag for scottyctl'
    required: false
    default: 'next'

outputs:
  app-url:
    description: 'Deployed application URL(s) - multi-line string with one URL per line'
    value: ${{ steps.create.outputs.app-url }}
  app-status:
    description: 'Application status'
    value: ${{ steps.create.outputs.app-status || steps.destroy.outputs.app-status }}
  app-name:
    description: 'Application name (echo of input)'
    value: ${{ inputs.app-name }}

runs:
  using: 'composite'
  steps:
    - name: Pull scottyctl Docker image
      shell: bash
      run: |
        echo "Pulling scottyctl:${{ inputs.scottyctl-version }}..."
        docker pull ghcr.io/factorial-io/scottyctl:${{ inputs.scottyctl-version }}

    - name: Create application
      id: create
      if: inputs.action == 'create'
      shell: bash
      run: |
        set -e

        echo "Creating Scotty application: ${{ inputs.app-name }}"

        # Build base docker command
        CMD="docker run --rm"
        CMD="$CMD -v \"$GITHUB_WORKSPACE:/workspace\""
        CMD="$CMD -w \"/workspace/${{ inputs.folder }}\""
        CMD="$CMD -e SCOTTY_SERVER=\"${{ inputs.scotty-server }}\""
        CMD="$CMD -e SCOTTY_ACCESS_TOKEN=\"${{ inputs.scotty-token }}\""
        CMD="$CMD ghcr.io/factorial-io/scottyctl:${{ inputs.scottyctl-version }}"
        CMD="$CMD app:create ${{ inputs.app-name }}"
        CMD="$CMD --folder ."

        # Add services (multi-line input)
        if [ -n "${{ inputs.service }}" ]; then
          while IFS= read -r line; do
            if [ -n "$line" ]; then
              CMD="$CMD --service \"$line\""
            fi
          done <<< "${{ inputs.service }}"
        fi

        # Add app-blueprint if specified
        if [ -n "${{ inputs.app-blueprint }}" ]; then
          CMD="$CMD --app-blueprint \"${{ inputs.app-blueprint }}\""
        fi

        # Add TTL
        if [ -n "${{ inputs.ttl }}" ]; then
          CMD="$CMD --ttl \"${{ inputs.ttl }}\""
        fi

        # Add basic auth
        if [ -n "${{ inputs.basic-auth }}" ]; then
          CMD="$CMD --basic-auth \"${{ inputs.basic-auth }}\""
        fi

        # Add boolean flags
        if [ "${{ inputs.allow-robots }}" = "true" ]; then
          CMD="$CMD --allow-robots"
        fi

        if [ "${{ inputs.destroy-on-ttl }}" = "true" ]; then
          CMD="$CMD --destroy-on-ttl"
        fi

        # Add custom domains (multi-line input)
        if [ -n "${{ inputs.custom-domain }}" ]; then
          while IFS= read -r line; do
            if [ -n "$line" ]; then
              CMD="$CMD --custom-domain \"$line\""
            fi
          done <<< "${{ inputs.custom-domain }}"
        fi

        # Add environment variables (multi-line input)
        if [ -n "${{ inputs.env }}" ]; then
          while IFS= read -r line; do
            if [ -n "$line" ]; then
              CMD="$CMD --env \"$line\""
            fi
          done <<< "${{ inputs.env }}"
        fi

        # Add env-file
        if [ -n "${{ inputs.env-file }}" ]; then
          CMD="$CMD --env-file \"${{ inputs.env-file }}\""
        fi

        # Add registry
        if [ -n "${{ inputs.registry }}" ]; then
          CMD="$CMD --registry \"${{ inputs.registry }}\""
        fi

        # Add middleware (multi-line input)
        if [ -n "${{ inputs.middleware }}" ]; then
          while IFS= read -r line; do
            if [ -n "$line" ]; then
              CMD="$CMD --middleware \"$line\""
            fi
          done <<< "${{ inputs.middleware }}"
        fi

        # Execute command and capture output
        echo "Executing: $CMD"
        OUTPUT=$(eval $CMD 2>&1)
        EXIT_CODE=$?

        echo "$OUTPUT"

        if [ $EXIT_CODE -ne 0 ]; then
          echo "Failed to create application"
          exit $EXIT_CODE
        fi

        # Extract URLs (all lines containing https://)
        URLS=$(echo "$OUTPUT" | grep -o 'https://[^ ]*' || echo "")
        echo "app-url<<EOF" >> $GITHUB_OUTPUT
        echo "$URLS" >> $GITHUB_OUTPUT
        echo "EOF" >> $GITHUB_OUTPUT

        # Extract status (best effort)
        STATUS=$(echo "$OUTPUT" | grep -i "status" | head -1 | awk '{print $NF}' || echo "created")
        echo "app-status=$STATUS" >> $GITHUB_OUTPUT

        echo "Application created successfully"
